@mixin cover-image($name) {
  background: center top no-repeat;
  background-size: cover;

  .core & {
    background-image: url('/images/d-#{$name}-960.jpg');
    -ms-filter: "progid:DXImageTransform.Microsoft.AlphaImageLoader(src='/images/d-#{$name}-960.jpg', sizingMethod='scale')";
  }

  .enhanced & {
    @include mq($until: 'medium', $and: '(orientation: portrait)') {
      background-image: url('/images/m-#{$name}-640.jpg');
    }

    @include mq($until: 'medium', $and: '(orientation: landscape)') {
      background-image: url('/images/d-#{$name}-960.jpg');
    }

    // Background texture only
    @include mq($from: 'medium', $and: '(orientation: portrait)') {
      background-image: url('/images/m-#{$name}-1050.jpg');
    }

    @include mq($from: 'medium', $and: '(orientation: landscape)') {
      background-image: url('/images/d-#{$name}-1600.jpg');
    }
  }
}

%cover {
  min-height: 500px;
  height: 100%;
  height: 100vh;
}

%cover-content {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  box-sizing: border-box;
}

.cover {
  @extend %cover;
}

.cover__content {
  @extend %cover-content;
}

.cover__image {
  @extend %cover-content;
  @include cover-image('hero');

  .enhanced & {
    // No easy background-attachment: fixed on iOS
    position: fixed;
    z-index: -1;
    // Viewport size changes when browser chrome moves in/out of view.
    // therefore a % based height would mean extra reflows.
    height: 100vh;
    // Forcing hardware acceleration means this won't get re-painted all the
    // time. This even extends below the viewport so when the browser chrome
    // is hidden we don't get ugly gaps that need to be painted.
    transform: translate3d(0, 0, 0);
  }

}

.cover__image__mask {
  .enhanced & {
    @extend %cover-content;
    background: rgba(#232322, 0.9);
    opacity: 0;
    transition: opacity 0.1s;
    will-change: opacity;
  }
}

